<div style="display: flex; flex-direction: column">
    <h1>Liskov Substitution Principle</h1>
    
    <div style="text-align:right; font-size:small">
        <span>
            Отыщи всему начало, и ты многое поймешь.
            <br>
            Где начало того конца, которым оканчивается начало?
        </span>
        <p>Козьма Прутков</p>
    </div>
    
    <div style="text-align:justify">
        <p>
            <b>
                Liskov Substitution Principle, LSP:
            </b>
            <i>
                «Должна быть возможность вместо базового типа подставить любой его подтип.»
            </i>
        </p>
        <p>
            <i>«...Если для каждого объекта o1 типа S существует объект o2 типа T такой, что
            для всех программ P, определенных в терминах T, поведение P не изменяется при
            замене o2 на o1, то S является подтипом (subtype) для T» (Лисков Б. Абстракция
            данных и иерархия. - 1988).</i>
        </p>

        <p>
            Наследование и полиморфизм являются ключевыми инструментами «объектноориентированного» разработчика для борьбы со сложностью и получения простого и расширяемого решения. 
            Наследование используется в большинстве паттернов
            проектирования и лежит в основе принципа «открыт/закрыт» и принципа инверсии зависимостей.
        </p>
        <p>
            Большинство опытных разработчиков знают, что с наследованием не все так просто.
            Наследование — это одна из самых сильных связей в объектно-ориентированном 
            мире, которая крепко привязывает наследников к базовому классу (сильнее только отношение дружбы). 
            Кроме того, не всегда легко ответить на два простых вопроса.
            <ul>
                <li>1. Когда наследование уместно?</li>
                <li>2. Как его реализовать корректно?</li>
            </ul>
        </p>
        <p>    
            Наследование обычно моделирует отношение «ЯВЛЯЕТСЯ» (IS-A Relationship)
            между классами. Говорят, что экземпляр наследника также ЯВЛЯЕТСЯ экземпляром базового класса, что выражается в возможности использования экземпляров
            наследника везде, где ожидается использование базового класса. Данный вид наследования называется также наследованием подтипов (Subtype Inheritance), но
            он не является единственно возможным. Бертран Мейер в своей книге «Объектноориентированное конструирование программных систем» приводит 12 (!) различных видов наследования, 
            включая наследование реализации (закрытое наследование), IS-A, Can-Do (реализация интерфейсов) и т. п.
        </p>
        <p>
            Большинство современных объектно-ориентированных языков программирования
            не поддерживают множественного или закрытого наследования, поэтому наибольший
            интерес вызывает именно наследование подтипов. Принцип подстановки Лисков
            призван помочь в корректной реализации этого вида наследования, что также должно
            помочь отказаться от наследования, если его корректная реализация невозможна.
        </p>
        <p>
            Чтобы принцип подстановки был полезнее, нужно подобрать для него более звучное определение. 
            Проблема с приведенными ранее определениями в том, что определение Роберта Мартина повторяет определение отношения «ЯВЛЯЕТСЯ»,
            а исходное определение от Барбары Лисков выглядит слишком академичным и также слабо применимым на практике. Одно из лучших определений этого принципа
            находится на сайте Уорда Каннингема c2.com: 
            <i>
                «Должна существовать возможность использовать объекты производного класса вместо объектов базового класса.
                Это значит, что объекты производного класса должны вести себя согласованно, согласно контракту базового класса».
            </i>
        </p>
        <h2>Для чего нужен принцип подстановки Лисков</h2>
        <p>
            Основной смысл любой иерархии наследования в том, что она позволяет использовать базовые классы полиморфным образом, не задумываясь о том, экземпляр какого конкретного класса был передан.
        </p>

        <p>
            В своем приложении мы можем абстрагироваться от конкретной реализации
            потоков ввода-вывода (Streams), коллекций и последовательностей (Enumerables),
            провайдеров, репозиториев и т. п. Но чтобы поведение приложения оставалось
            корректным, оно должно отталкиваться от некоторых допущений, справедливых
            для всех реализаций абстракции: возвращаемое значение никогда не равно null,
            будут генерироваться исключения лишь определенного типа, любая реализация
            должна сохранить данные в базу данных (неважно какую), или метод добавления элемента обязательно его добавит и размер коллекции увеличится на единицу.
        </p>

        <p>
            Здесь мы сталкиваемся с такой особенностью: с одной стороны, любая реализация
            должна следовать некоторому абстрактному протоколу или контракту, а с другой — она должна иметь возможность выбрать конкретный способ реализации
            этого протокола. Именно контракт, неважно, формальный или нет, описывает
            ожидаемое видимое поведение абстракции, оставляя реализации решать, каким
            образом это поведение будет реализовано.
        </p>

        <p>
            Исходный посыл Мейера заключается не столько в расширяемости системы, 
            сколько в управляемости процесса разработки: 
            «Необходимо, особенно с точки зрения руководителя проекта, закрывать модули. 
            В системе, состоящей из многих модулей, большинство модулей зависимы. 
            Например, модуль интерфейса пользователя может зависеть от модуля синтаксического разбора - синтаксического анализатора и модуля графики. 
            Синтаксический анализатор может зависеть от модуля лексического анализа и т. д. 
            Если не закрывать модуль до тех пор, пока не будет уверенности, что он уже содержит все необходимые компоненты, 
            то невозможно будет завершить разработку многомодульной программы: каждый из разработчиков будет вынужден ожидать, когда же завершат свою работу все остальные».
        </p>
        <p>
            Если же реализация (то есть наследники) не будет знать об этом протоколе или не будет ему следовать, 
            то в приложении мы будем вынуждены обрабатывать конкретную реализацию специальным образом, что сводит на нет идею использования
            наследования и полиморфизма.
        </p>
        
        <p>
            Почему важно следовать принципу подстановки Лисков? Потому что в противном случае:
            <ul>
                <li>
                    иерархии наследования приведут к неразберихе. Она будет заключаться в том,
                    что передача в метод экземпляра класса-наследника вызовет странное поведение
                    существующего кода;
                </li>
                <br>
                <li>
                    юнит-тесты базового класса никогда не будут проходить для наследников.
                </li>
            </ul>
        </p>

        <h2>Классический пример нарушения: квадраты и прямоугольники (см. стр. 263)</h2>

        <h2>Типичные примеры нарушения LSP</h2>

        <p>
            Типичными примерами нарушения LSP являются следующие.
            <ul>
                <li>
                    Производные классы используются полиморфным образом, но их поведение не
                    согласуется с поведением базового класса: генерируются исключения, не описанные контрактом базового класса, или не выполняются действия, 
                    предполагаемые контрактом базового класса.
                </li>
                <br>
                <li>
                    Контракт базового класса настолько нечеткий, что реализовать согласованное поведение наследником просто невозможно.
                </li>
            </ul>
        </p>

        <h2>Выводы</h2>
        <p>
            Принцип подстановки Лисков не является панацеей в вопросах наследования, 
            он лишь помогает формализовать, в каких пределах может варьироваться поведение наследника 
            с точки зрения контракта базового класса. В своих трудах Барбара Лисков строила
            анализ на основе контрактов класса: предусловий, постусловий и инвариантов. 
            Именно с помощью контрактов мы можем хотя бы с некоторой долей уверенности утверждать, 
            что поведение наследника и базового класса являются согласованными.
        </p>

        <p>
            Когда речь касается наследования, разработчик должен четко понимать, для чего
            он его использует и каким образом клиенты будут пользоваться наследниками:
            лишь через призму базового класса, напрямую или же и так и этак. Когда тип
            предназначен лишь для полиморфного использования, то такое наследование является наследованием подтипов и должно соответствовать принципу подстановки
            Лисков. Если же создание наследника нужно для повторного использования кода
            базового класса или производный класс будет всегда использоваться напрямую, то
            вполне возможно, что его интерфейс и контракт будут изменены: добавлены новые
            методы и/или не реализованы некоторые методы базового класса.
        </p>

        <p>
            Нельзя говорить, что второй пример использования наследования вреден или не
            должен использоваться на практике — как минимум он должен быть обдуман
            и четко описан в документации класса-наследника, чтобы пользователь вашего
            класса знал о таком решении. Создание иерархий наследования, удобных для развития и использования, — это сложный итеративный процесс. 
            Четкое следование принципам проектирования вообще и принципу замещения в частности не гарантирует хорошего дизайна или удобной в использовании иерархии наследования.
        </p>
    </div>
    
    <div style="text-align:right; font-size:small">
        <b><i>Сергей Тепляков. "Паттерны проектирования на платформе .NET"</i></b>
    </div>
</div>
