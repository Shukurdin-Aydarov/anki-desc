<div style="display: flex; flex-direction: column">
    <h1>Open-Closed Principle</h1>
    
    <div style="text-align:right; font-size:small">
        <span>
            Многие вещи нам непонятны не потому, 
            <br>
            что наши понятия слабы; но потому,
            <br>
            что сии вещи не входят в круг наших понятий.
        </span>
        <p>Козьма Прутков</p>
    </div>
    
    <div style="text-align:justify">
        <p>
            <b>
                Interface Segregation Principle, ISP:
            </b>
            <i>
                «Клиенты не должны вынужденно зависеть от методов, которыми не пользуются.»
            </i>
        </p>
        <p>
            Необходимым условием повторного применения кода является простота его использования. 
            Разработчик никогда не будет использовать чужой код, если ему
            проще реализовать эту возможность самостоятельно, чем искать чье-то решение и разбираться в нем. 
            С одной стороны, программисты ленивы и не склонны делать больше, 
            чем того требует задача, но с другой — они достаточно горды и упрямы для того, 
            чтобы считать любое чужое решение по определению менее удачным, чем собственное.
        </p>
        <p>
            Одной из причин скептического отношения к повторно используемому коду является сложность проектирования библиотек, простых и удобных в применении. 
            С одной стороны, библиотека должна решать базовые вещи простым и интуитивно понятным способом, с другой — она должна делать возможными
            и более сложные сценарии. Добиться простоты использования кода можно за счет проектирования чистых интерфейсов — интерфейсов, предоставляющие
            цельный набор операций, которого будет необходимо и достаточно большинству клиентов.
        </p>

        <h2>Для чего нужен принцип разделения интерфейса</h2>
        
        <p>
            Принцип разделения интерфейса предназначен для получения простого и слабосвязного кода. 
            Он гласит, что клиенты должны зависеть лишь от тех методов, которые используют, и не должны знать о существовании не интересующих их частей
            в интерфейсе применяемых ими сервисов. Как мы увидим позднее, разработчик
            сервиса не всегда знает о том, кто и как его будет использовать. Поэтому может
            потребоваться несколько итераций для перегруппировки методов таким образом,
            чтобы их использование было удобным максимальному числу клиентов.
        </p>
        <p>    
            Данный принцип является частным случаем принципа наименьшего знания, который много лет используется в нашей индустрии. 
            Для получения простого в сопровождении кода каждый класс должен знать минимум информации об окружающем коде, необходимой для решения своей задачи. 
            На практике это проявляется в минимизации числа зависимостей и стремлении к использованию наиболее простых типов зависимостей.
        </p>
        <p>
            <p>
                Сопровождаемость класса определяется его внутренней сложностью и связанностью с другими классами. Чем больше у класса зависимостей, тем сложнее понять
                его роль, сложнее тестировать и использовать повторно. К тому же большое число
                связей увеличивает вероятность поломки класса при изменении зависимостей.
                Стабильность зависимостей играет важную роль. Чем ниже вероятность изменения
                интерфейса зависимости или его поведения, тем меньше вероятность поломки вашего кода. 
                Далее представлены виды зависимостей, стабильность которых уменьшается от очень стабильной до нестабильной:
            </p>
            <ul>
                <li>примитивные типы;</li>
                <br>
                <li>объекты-значения (неизменяемые пользовательские типы);</li>
                <br>
                <li>объекты со стабильным интерфейсом и поведением (пользовательские типы,
                    интерфейс которых стабилен, а поведение не зависит от внешнего окружения);</li>
                <br>
                <li>объекты с изменчивыми интерфейсом и поведением (типы расположены на стыке модулей, которые постоянно подвергаются изменениям, или типы, которые
                    работают с внешним окружением: файлами, базами данных, сокетами и т. п.).</li>
            </ul>
        </p>

        <p>
            Принцип разделения интерфейсов также соответствует одному из принципов контрактного программирования: требуй меньше, но гарантируй больше. В терминах
            контрактов это проявляется в виде использования более слабого предусловия и более строгого постусловия. Чем проще аргументы метода, тем проще удовлетворять
            предусловиям метода. На практике это правило выражается в использовании наиболее простых типов (согласно приведенной ранее шкале), а также базовых типов
            в качестве входных аргументов.
        </p>

        <p>
            Если метод использует лишь члены интерфейса IEnumerable<T>, то нет смысла
            заявлять, что он требует List<T>. Если метод может работать с любым потоком
            ввода-вывода, то лучше ему принимать Stream, а не MemoryStream. Если классу
            требуется конфигурация, то лучше передавать в аргументах конструктора экземпляр класса Configuration (объект-значение), а не провайдер IConfigurationProvider, который будет читать конфигурацию в методе ReadConfiguration.
        </p>

        <h2>SRP versus ISP</h2>

        <p>
            Принцип разделения интерфейсов является довольно простым и очень полезным принципом проектирования. 
            Но его иногда путают с принципом единственной обязанности. 
            Причина такого недопонимания лежит в классическом описании ISP.
        </p>

        <p>
            Этот принцип относится к недостаткам «жирных» интерфейсов. Говорят, что класс
            имеет «жирный» интерфейс, если функции этого интерфейса недостаточно хорошо
            сцеплены (not cohesive), иными словами, если интерфейс класса можно разбить на
            группу методов. Каждая группа предназначена для обслуживания разных клиентов.
            Одним клиентам нужна одна группа методов, другим — другая.
        </p>

        <p>
            Проблема этого определения в том, что в нем акцент делается на «жирности».
            «Жирный» интерфейс, который содержит несколько групп методов, недостаточно
            сцепленных между собой, нарушает принцип единственной обязанности. 
            Такие методы используются разными клиентами и будут развиваться независимо. 
            Однако все не так просто.
        </p>
        
        <p>
            Давайте вспомним, как мы определяем, что класс или модуль нарушает принцип единственной обязанности. 
            Мы открываем исходный код этого класса или модуля и смотрим, не делает ли он слишком многого. 
            Если класс или модуль отвечает за выполнение разнородных задач, значит, он нарушает принцип единственной обязанности. Но можем ли мы, глядя на класс или его интерфейс, сказать, нарушает
            он принцип разделения интерфейсов или нет?
        </p>
        <p>
            Например, у нас есть класс репозитория, который содержит CRUD-операции.
            Нарушает ли он ISP? Мы не знаем! Нарушение этого принципа зависит не столько от самого класса, сколько от сценариев его использования. 
            Если в нашей бизнесмодели четко разделяются операции чтения и обновления данных, то наличие
            одного класса со всеми операциями работы с данными однозначно делает интерфейс слишком «жирным». 
            В то же время если приложение содержит множество простых форм пользовательского интерфейса, которые соотносятся как 1 × 1 с нашими
            поставщиками данных, то принцип ISP не нарушается.
        </p>

        <p>
            Из предыдущего обсуждения можно вывести важное различие принципов SRP и ISP.
            Следование принципу единственной обязанности приводит к связным (cohesive)
            классам, что позволяет с меньшими усилиями их понимать и развивать. Следование
            принципу разделения интерфейсов уменьшает связанность (coupling) между классами и их клиентами, ведь теперь клиенты используют более простые зависимости, чем раньше.
        </p>

        <h2>Типичные примеры нарушения ISP</h2>
        <p>
            <p>
                Типичными примерами нарушения ISP являются следующие.
            </p>

            <ul>
                <li>Метод принимает аргументы производного класса, хотя достаточно использовать
                    базовый класс.</li>
                <br>
                <li>У класса два или более ярко выраженных вида клиентов.</li>
                <br>
                <li>Класс зависит от более сложной зависимости, чем нужно: принимает интерфейс
                    провайдера вместо результатов его работы и т. п.</li>
                <br>
                <li>Класс зависит от сложного интерфейса, что делает его зависимым от всех типов,
                    используемых в этом интерфейсе.</li>
            </ul>
        </p>

        <h2>Выводы</h2>
        <p>
            Принцип разделения интерфейсов является частным случаем управления зависимостями и борьбы со сложностью. Чем проще зависимости класса, тем легче понять,
            что класс делает, поскольку в голове приходится держать лишь минимальное число ненужных деталей. Чем стабильнее зависимости класса, тем меньше вероятность
            того, что его поведение будет нарушено при внесении изменений в другие части системы.
        </p>

        <p>
            Принцип разделения интерфейсов лежит на стыке классов или модулей. 
            Глядя на исходный код некоторого класса, мы можем сказать, соответствует ли реализация 
            принципу единственной обязанности, принципу замещения Лисков или принципу «открыт/закрыт». 
            Но лишь по исходному коду класса или его интерфейса мы не можем судить о том, нарушает он принцип разделения интерфейсов или нет.
            Для этого нужно посмотреть контекст его использования: есть ли разные группы клиентов, которые используют его по-разному, или нет.
        </p>

        <p>
            Если класс используется разными клиентами, это может говорить о слишком большом числе обязанностей, поэтому его нужно упростить. 
            В некоторых случаях у класса может быть одна обязанность, которая рассматривается клиентами с разных точек зрения. 
            Тогда этот факт нужно сделать явным путем реализации двух или более интерфейсов.
        </p>
    </div>
    
    <div style="text-align:right; font-size:small">
        <b><i>Сергей Тепляков. "Паттерны проектирования на платформе .NET"</i></b>
    </div>
</div>