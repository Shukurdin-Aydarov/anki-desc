<div style="display: flex; flex-direction: column">
    <h1>Single-Responsibility Principle</h1>
    
    <div style="text-align:right; font-size:small">
        <span>
            Нельзя объять необъятное.
        </span>
        <p>Козьма Прутков</p>
    </div>
    
    <div style="text-align:justify">
        <p>
            <b>
                Single-Responsibility Principle, SRP:
            </b>
            <i>
                «У класса должна быть только одна причина для изменения.»
            </i>
        </p>
        <p>
            В разработке ПО есть одна неизменная составляющая — неизбежность изменений.
            Как бы мы ни старались, как бы ни пытались продумать все до мелочей, рано или
            поздно требования изменятся. Требования меняются из-за изначального недопонимания задачи, изменений во внешнем мире, более точного осознания собственных
            нужд заказчиком или десятков других причин. На самом деле важны не столько
            причины изменений, сколько наши возможности по адаптации системы к новым
            требованиям и легкость внесения изменений.
        </p>
        <p>
            Многие разработчики считают, что обобщенные решения являются лучшим способом борьбы с изменениями требований. Полагается, что если предусмотреть все
            возможные сценарии и предоставить различные точки расширения, то система
            сможет решать любые задачи пользователя. Но у этого подхода есть несколько
            серьезных недостатков. Мы (разработчики) очень плохо разбираемся в вопросах
            предсказания будущего, не знаем, как изменятся требования в будущем и в какой
            плоскости система должна легко расширяться. 
            А поскольку гибкость всегда приводит к увеличению сложности, то полученное решение не всегда справляется с исходной задачей и плохо поддается модификации.
        </p>
        <p>    
            Другой подход к обеспечению расширяемости заключается в использовании наиболее простых решений: программная сущность (класс, модуль, метод) должна по
            возможности решать лишь одну задачу, но делать это хорошо. Как это предотвращает проблему изменений? Очень просто. Чем меньше у метода, класса или модуля вспомогательных задач, тем ниже вероятность случайных изменений.
        </p>
        <p>
            Фредерик Брукс в своей книге «Мифический человеко-месяц» вводит понятия
            естественной сложности (essential complexity) и привнесенной или случайной
            сложности (accidental complexity). Естественная сложность исходит из предметной
            области и является неотъемлемой частью любого решения. 
            Привнесенная сложность внесена нами в процессе реализации за счет плохого дизайна, неудачно выбранных библиотек или неподходящего языка программирования.
        </p>
        <p>
            Изменения, вносимые в систему, также можно разделить на естественные, которые
            возникают из-за изменения бизнес-логики или требуемого поведения, и случайные,
            которые мы вынуждены вносить во второстепенные модули из-за неудачного дизайна. Изменения в законодательстве приведут к изменениям в классе вычисления
            заработной платы и являются естественными. Но мы не хотим его менять при изменении пользовательского интерфейса, смене базы данных или из-за изменений
            формата одного из отчетов.
        </p>

        <p>
            Существует ряд патологических случаев нарушения принципа единственной обязанности: классы пользовательского интерфейса, которые знают о бизнес-правилах
            или работают напрямую с базой данных, или классы Windows-сервисов с обилием
            бизнес-логики. Есть примеры нарушения SRP на уровне приложений: Windows
            Forms-приложение, в котором располагается WCF-сервис, Windows-сервис, взаимодействующий с пользователем с помощью диалоговых окон. Эти примеры показывают, что нарушения SRP бывают как на микроуровне — на уровне классов
            или методов, так и на макроуровне — на уровне модулей, подсистем и целых приложений.    
        </p>

        <p>
            Приведенные ранее примеры не столько нарушают SRP, сколько противоречат
            здравому смыслу. В реальном мире проблемы бывают более тонкими, когда один
            разработчик говорит, что дизайн хорош, а для другого он серьезно «попахивает»
            и вам хочется найти весомые аргументы против текущего решения. 
            <b>Чтобы понять, нарушает ли код принцип единственной обязанности, важно понимать, какую
                проблему он должен решать.
            </b>    
        </p>

        <h2>Для чего нужен SRP</h2>

        <p>
            Принцип единственной обязанности предназначен для борьбы со сложностью.
            Когда в приложении всего 200 строк, то дизайн как таковой вообще не нужен. Достаточно аккуратно написать 5–7 методов и решить задачу любым доступным
            способом. Проблемы возникают, когда система растет и увеличивается в размере.
        </p>

        <p>
            Зависимость между числом строк кода и сложностью решения является нелинейной. Добавление каждой новой функции в систему требует все больше и больше
            усилий. Когда речь касается десятков и сотен тысяч строк кода, приходится вспоминать такие «страшные» понятия, как «абстракция» и «сокрытие информации»,
            и лучше продумывать обязанности каждого класса. При разработке крупной системы очень важно иметь возможность сосредоточиться на главной задаче метода,
            класса или модуля и выбросить из рассмотрения все второстепенные детали.
        </p>

        <p>
            Основным строительным блоком объектно-ориентированного приложения является класс, поэтому обычно принцип единственной обязанности рассматривается
            в контексте класса. Но поскольку основную работу выполняют методы, то очень
            важно, чтобы они также были нацелены на решение одной задачи.
        </p>

        <p>
            Основная сложность принципа SRP в том, что понятие «обязанности» является относительным. 
            Если мы говорим, что у класса или метода должна быть лишь одна обязанность, то может ли метод валидировать свои аргументы? Или логировать
            определенные этапы своей работы? А может ли класс читать и сохранять данные?
        </p>

        <p>
            Наличие или отсутствие нарушения SRP очень зависит от того, насколько сложным
            является каждый из описанных ранее шагов. Метод будет нарушать SRP, если
            валидация аргументов занимает 40 строк кода и находится в разных его частях.
            Метод также будет нарушать SRP, если за обилием трассировочных сообщений не
            видно его основной логики. Но класс может и не нарушать SRP, если он читает
            и сохраняет данные, но на каждую операцию требуется две строки кода.
        </p>

        <h2>Типичные примеры нарушения SRP</h2>
        <p>
            <p>
                Типичными примерами нарушения SRP являются:
            </p>
            <ul>

                <li>
                    <b>Смешивание логики с инфраструктурой.</b> 
                    Бизнес-логика смешана с представлением, слоем персистентности, находится внутри WCF или Windows-сервисов.
                    Должна быть возможность сосредоточиться на бизнес-правилах, не обращая
                    внимания на второстепенные инфраструктурные детали.
                </li>
                <br>
                <li>
                    <b>Слабая связность (lowcohesion).</b> 
                    Класс/модуль/метод не является цельным
                    и решает несколько несвязанных задач. Проявляются несколько групп методов,
                    каждая из которых обращается к подмножеству полей, не используемых другими методами.
                </li>
                <br>
                <li>
                    <b>Выполнение нескольких несвязанных задач.</b> 
                    Класс/модуль может быть цельным, но решать несколько несвязанных задач (вычисление заработной платы
                    и построение отчета). 
                    Класс/модуль/метод должен быть сфокусированным на
                    решении минимального числа задач.
                </li>
                <br>
                <li>
                    <b>Решение задач разных уровней абстракции.</b> 
                    Класс/метод не должен отвечать за задачи разного уровня. Например, класс удаленного заместителя не должен
                    самостоятельно проверять аргументы, заниматься сериализацией и шифрованием. 
                    Каждый из этих аспектов должен решаться отдельным классом.
                </li>
            </ul>
        </p>

        <h2>Выводы</h2>
        <p>
            Следование принципам проектирования является не статической, а динамической
            характеристикой дизайна. Наибольшая опасность заключается в «загнивании»
            дизайна, когда внесение нескольких изменений приводит к разрастанию обязанностей и увеличению сложности. То, что вчера казалось лишь одной обязанностью,
            сегодня может потребовать целой иерархии классов. Каждый раз при изменении
            логики нужно анализировать дизайн на соответствие здравому смыслу и принципам проектирования.
        </p>

        <p>
            Важность принципа единственной обязанности резко возрастает при увеличении
            сложности. Если решение перестает помещаться в голове, то пришло время разбить его на более простые составляющие, каждая из которых будет решать лишь
            одну задачу.
        </p>
    </div>
    
    <div style="text-align:right; font-size:small">
        <b><i>Сергей Тепляков. "Паттерны проектирования на платформе .NET"</i></b>
    </div>
</div>