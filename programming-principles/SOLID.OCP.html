<div style="display: flex; flex-direction: column">
    <h1>Open-Closed Principle</h1>
    
    <div style="text-align:right; font-size:small">
        <span>
            Эффективные проекты контролируют изменения;
            <br>
            неэффективные проекты находятся
            <br>
            под контролем изменений.
        </span>
        <p>Стив Макконнелл. Остаться в живых</p>
    </div>
    
    <div style="text-align:justify">
        <p>
            <b>
                Open-Closed Principle, OCP:
            </b>
            <i>
                «Программные сущности (классы, модули, функции и т. п.) должны быть открытыми для расширения, но закрытыми для модификации.»
            </i>
        </p>
        <p>
            Одна из причин «загнивания» дизайна кроется в страхе внесения изменений. 
            Разработчики и менеджеры должны быть уверены в том, что изменения являются корректными и не приведут к появлению ошибок в других частях системы. 
            Простые классы и модули, которые соответствуют принципу единственной обязанности, являются хорошей стартовой точкой для получения адаптивного дизайна, но этого не всегда достаточно.
        </p>
        <p>
            По мере развития в системе появляются семейства типов с общим поведением и схожими интерфейсами. 
            Возникают иерархии наследования, в базовых классах которых помещается общее поведение, которое наследники изменяют при необходимости. 
            Это позволяет повторно использовать значительную часть логики базовых классов, а также упрощает добавление типов с новым поведением.
        </p>
        <p>
            Полученные иерархии типов одновременно являются открытыми и закрытыми. 
            <b>Открытость говорит о простоте добавления новых типов, а закрытость - о стабильности интерфейсов базовых классов иерархии.</b>
        </p>
        <p>    
            Принцип «открыт/закрыт» является самым неоднозначным из всех SOLID-принципов. 
            Его неоднозначность кроется в противоречивости его определения, а подкрепляется разнообразными описаниями этого принципа в разных источниках. 
            Неудивительно, что даже такие яркие представители нашей отрасли, как Эрик Липперт и Джон Скит, относятся к этому принципу неоднозначно и признаются в его непонимании.
        </p>
        <p>
            Принцип «открыт/закрыт» был изначально сформулирован Бертраном Мейером в первом издании его книги «Объектно-ориентированное конструирование программных систем» еще в 1988 году, 
            но популярность этот принцип завоевал благодаря трудам Роберта Мартина.
        </p>
        <p>
            <p>
                <b>Определение от Роберта Мартина:</b>
                программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для модификации. 
                Таким образом, у модулей есть две основные характеристики.
            </p>
            <ul>

                <li>

                    <b>Они открыты для расширения.</b> 
                    Это означает, что поведение модуля можно расширить. 
                    Когда требования к приложению изменяются, мы добавляем в модуль новое поведение, отвечающее изменившимся требованиям. 
                    Иными словами, мы можем изменить состав функций модуля.
                </li>
                <br>
                <li>
                    <b>Они закрыты для модификации.</b> 
                    Расширение поведения модуля не сопряжено с изменениями в исходном или двоичном коде модуля. 
                    Двоичное исполняемое представление модуля, будь то компонуемая библиотека, DLL или EXE-файл, остается неизменным.
                </li>
            </ul>
        </p>

        <p>
            На основе этого определения может сложиться впечатление, 
            что следование принципу «открыт/закрыт» подразумевает использование расширяемых решений на основе подключаемых модулей (pluggable architecture) и обилие наследования. 
            На самом деле это не так, и даже сам автор определения со временем несколько изменил свое отношение к этому принципу. 
            В своей статье An Open and Closed Case Роберт Мартин написал, 
            что с годами он стал более мудрым и менее категоричным в своих высказываниях (хотя на момент описания принципа «открыт/закрыт» в статье 1996 года ему было всего 43).
        </p>

        <p>
            <p>
                <b>Определение от Бертрана Мейера:</b>
                модули должны иметь возможность быть как открытыми, так и закрытыми. При этом понятия открытости и закрытости определяются так.
            </p>
            <ul>

                <li>
                    <b>Модуль называют открытым,</b> если он еще доступен для расширения. Например, имеется возможность расширить множество операций в нем или добавить поля к его структурам данных.
                </li>
                <br>
                <li>
                    <b>Модуль называют закрытым,</b> если он доступен для использования другими модулями. 
                    Это означает, что модуль (его интерфейс - с точки зрения сокрытия информации) уже имеет строго определенное окончательное описание. 
                    На уровне реализации закрытое состояние модуля означает, что можно компилировать модуль, сохранять в библиотеке и делать его доступным для использования другими модулями (его клиентами).
                </li>
            </ul>
        </p>

        <p>
            <b>Так что же означает принцип «открыт/закрыт»?</b>
        </p>

        <p>
            Исходный посыл Мейера заключается не столько в расширяемости системы, 
            сколько в управляемости процесса разработки: 
            «Необходимо, особенно с точки зрения руководителя проекта, закрывать модули. 
            В системе, состоящей из многих модулей, большинство модулей зависимы. 
            Например, модуль интерфейса пользователя может зависеть от модуля синтаксического разбора - синтаксического анализатора и модуля графики. 
            Синтаксический анализатор может зависеть от модуля лексического анализа и т. д. 
            Если не закрывать модуль до тех пор, пока не будет уверенности, что он уже содержит все необходимые компоненты, 
            то невозможно будет завершить разработку многомодульной программы: каждый из разработчиков будет вынужден ожидать, когда же завершат свою работу все остальные».
        </p>
        <p>
            Другими словами, Мейер говорит о том, что интерфейс модуля должен быть закрытым, 
            а реализация и точное поведение могут варьироваться и оставаться открытыми для изменений.
        </p>
        
        <p>
            Когда нам может понадобиться изменять поведение без изменения интерфейса?
            Например, когда у существующего класса появляется вторая группа клиентов,
            которой требуется аналогичное поведение, но с небольшими изменениями. 
            В объектно-ориентированном мире это означает создание наследника, 
            который использует повторно весь код базового класса и переопределяет ряд методов для обеспечения нового поведения.
        </p>
        <p>
            В результате добавления наследника интерфейс и поведение нашего исходного класса (класс А) остается неизменным, 
            что гарантирует правильное функционирование его старых клиентов, а новые клиенты начинают использовать модифицированную версию класса (класс А').
        </p>

        <p>
            Данный принцип не говорит, что создание наследника — это единственный возможный или же необходимый способ адаптации существующего кода к новым
            требованиям. Бертран Мейер является признанным гуру в области объектно-ориентированного программирования и описывает в своей книге 12 видов наследования, но даже он относится к расширяемости модулей путем создания наследников
            с разумным прагматизмом: «Если имеется возможность переписать исходную
            программу так, чтобы она, без излишнего усложнения, смогла удовлетворять потребности нескольких разновидностей клиентов, то следует это сделать».
        </p>

        <p>
            Естественно, модуль должен модифицироваться при наличии в нем ошибок: 
            «Как принцип «открыт/закрыт», так и переопределение в механизме наследования не позволяет справиться с дефектами разработки, 
            не говоря уже об ошибках в программе. Если в модуле что-то не в порядке, то следует это сразу исправить в исходной программе, 
            не пытаясь разбираться с возникающей проблемой в производном модуле».
        </p>

        <h2>Какую проблему призван решить принцип «открыт/закрыт»</h2>
        <p>
            <b>Смысл принципа OCP:</b>
            дизайн системы должен быть простым и устойчивым к изменениям.
        </p>

        <p>
            Это значит, что, когда требования изменятся (не «если», а именно «когда»), 
            вы должны быть к этому готовы. Это не означает, что нужно создавать дополнительные уровни абстракции в приложении без необходимости. 
            Мы просто должны ограничить каскад изменений и свести их количество к минимуму.
        </p>

        <p>
            <b>Как этого добиться?</b>
            <p>
                Во-первых, за счет абстракции и инкапсуляции. 
                Выделение существенных (важных) частей системы в открытой части класса позволяет сосредоточиться на важных аспектах поведения, 
                не задумываясь о реализации, скрытой от клиентов в закрытой его части. 
                Важно понимать, что абстракция не требует наличия интерфейсов или абстрактных классов. 
                Класс String абстрагирует нас от конкретного представления строки и многих других подробностей, хотя и не реализует интерфейс IString.
            </p>
        </p>

        <p>
            Во-вторых, за счет наследования. Выделение интерфейсов и абстрактных классов позволяет думать о задаче еще более абстрактно. 
            Полиморфное поведение позволяет заменить один вариант реализации на другой во время исполнения, 
            а также позволит использовать повторно значительные фрагменты кода.
        </p>

        <h2>Типичные примеры нарушения принципа «открыт/закрыт»</h2>
        <p>
            <p>
                Типичными примерами нарушения принципа «открыт/закрыт» являются следующие.
            </p>
            <ul>

                <li>
                    <b>Интерфейс класса является нестабильным.</b> 
                    Постоянные изменения интерфейса класса, используемого во множестве мест, 
                    приводят к постоянным изменениям во многих частях системы.
                </li>
                <br>
                <li>
                    <b>«Размазывание» информации об иерархии типов.</b> 
                    В коде постоянно используются понижающие приведения типов (downcasting), 
                    что «размазывает» информацию об иерархии типов по коду приложения. 
                    Это затрудняет добавление новых типов и усложняет понимание текущего решения.
                </li>
            </ul>
        </p>

        <h2>Выводы</h2>
        <p>
            <b>Что такое OCP?</b>
            Фиксация интерфейса класса/модуля и возможность изменения реализации/поведения.
        </p>

        <p>
            <b>Цели OCP:</b>
            борьба со сложностью и ограничение изменений минимальным числом модулей.
        </p>

        <p>
            <b>Как мы реализуем OCP?</b>
            С помощью инкапсуляции, которая дает возможность изменять реализацию без изменения интерфейса, и посредством наследования, что позволяет заменить реализацию, не затрагивая существующих клиентов базового класса.
        </p>

        <p>
            Классический объектный подход позволяет легко добавлять
            новые типы в существующую иерархию типов, а функциональный подход позволяет легко добавлять новые операции. Проблема однобокости каждого из решений
            является одной из классических проблем программирования и носит название
            Expression Problem.
        </p>

        <p>
            Во время дизайна модуля нужно подумать о том, в каком направлении упрощать
            расширяемость. Если наиболее вероятным является добавление новых типов, то
            более подходящим будет классический объектный подход на основе наследования.
            Если более вероятным является добавление новых операций в существующую
            иерархию типов, то лучше подойдет функциональный подход на основе размеченных объединений (discriminate dunions) или на основе паттерна «Посетитель»
            в объектном мире.
        </p>

    </div>
    
    <div style="text-align:right; font-size:small">
        <b><i>Сергей Тепляков. "Паттерны проектирования на платформе .NET"</i></b>
    </div>
</div>